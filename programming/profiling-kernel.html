<!DOCTYPE html>
<html class="no-js" lang="ru">
<head>
    <title>Профилирование в Linux. Ядро</title>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/foundation.css" />
<link rel="stylesheet" href="/assets/css/foundation-icons.css" />
<link rel="stylesheet" href="/assets/css/main.css" />
<script src="/assets/js/vendor/modernizr.js"></script>

</head>
<body>
    <div class="wrapper">
        <div class="row show-for-large-up">
  <div class="small-12 columns">
    <div class="header">
      Несу подвиг добровольного безумия!
    </div>
  </div>
</div>

        <nav class="top-bar hide-for-large-up" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/">avd</a></h1>
    </li>
    <li class="toggle-topbar menu-icon">
      <a href="#">меню</a>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="left">
      <li><a href="/"><i class="fi-home"></i>&nbsp;&nbsp;Главная</a></li>
      <li><a class="disabled" href="/categories"><i class="fi-list"></i>&nbsp;&nbsp;Категории</a></li>
      <li><a href="/contacts.html"><i class="fi-at-sign"></i>&nbsp;&nbsp;Контакты</a></li>
    </ul>
  </section>
</nav>


        <div class="row">
            <div class="large-2 columns show-for-large-up">
  <ul class="side-nav">
      <li><a href="/"><i class="fi-home"></i>&nbsp;&nbsp;Главная</a></li>
      <li><a class="disabled" href="/categories"><i class="fi-list"></i>&nbsp;&nbsp;Категории</a></li>
      <li><a href="/contacts.html"><i class="fi-at-sign"></i>&nbsp;&nbsp;Контакты</a></li>
  </ul>
</div>

                <div class="large-10 small-12 columns ">
                    <article class="post-wrapper">
                        <div class="post-header">
                            <h1>Профилирование в Linux. Ядро</h2>
                            <h6 class="post-meta">
                              12 май 2014, в категории 
                              <a class="disabled" href="/categories/programming">programming</a>
                            </h6>
                        </div>
                        <div class="post-content">
                            <p>Содержание:</p>
<ol style="list-style-type: decimal">
<li><a href="/programming/profiling-intro.html">Введение</a></li>
<li><a href="/programming/profiling-gprof-gcov.html">Userspace profiling: gprof, gcov</a></li>
<li><a href="/programming/profiling-valgrind.html">Userspace profiling: Valgrind</a></li>
<li>Kernel profiling: Intro</li>
<li>Kernel profiling: ftrace</li>
<li>Kernel profiling: perf</li>
<li>Kernel profiling: SystemTap</li>
<li>Kernel profiling: ktap</li>
<li>Vendor specific profiling: Intel VTune</li>
</ol>
<p>С этой статьи я перехожу к основной своей цели – рассказе о профилировании ядра Linux: о средствах, доступных в ядре, о профилировщиках, о методах профилирования ядра и т.д. Если вы попали сюда случайно, то советую сначала прочитать <a href="/programming/profiling-intro.html">первую статью цикла</a>, в которой я описал проблему, которую я пытаюсь решить по ходу изучения профилировщиков.</p>
<p>В этой статье я расскажу о том, что есть в ядре для профилирования, как оно работает и как используется для профилирования.</p>
<h2 id="введение">Введение</h2>
<p>Иногда для того чтобы понять, что не так с вашей производительностью, недостаточно профилирования в пространстве пользователя. Как мы увидели на <a href="https://gist.github.com/dzeban/8731209">простом примере</a> (см. описание проблемы в <a href="/programming/profiling-intro.html">первой статье</a>), исследование приложения с помощью <a href="/programming/profiling-gprof-gcov.html">gprof, gcov</a> и <a href="/programming/profiling-valgrind.html">Valgrind</a> привело к тому, что все следы ведут в ядро – само приложение больше всего времени висит в ожидании системного вызова <code>pread</code>.</p>
<p>Как отследить работу этого системного вызова на первый взгляд непонятно – для профилирования ядра есть несколько профилировщиков, все они работают по своему, требуют разных подходов, конфигураций, анализа и пр. Разобраться непросто, это правда. Вообще история средств профилирования ядра довольно странная и мучительная. Являясь проектом разрабатываемым сообществом, Linux вобрал в себя несколько конкурирующих технологий профилирования и ещё больше способов профилирования. Более того, на данный момент, история далеко не закончилась, а даже наоборот – набирает обороты. С одной стороны есть тенденция к слиянию некоторых профилировщиков ядра (<em>perf</em> и <em>ftrace</em>), с другой стороны, в лагере динамических профилировщиков, появляются новые игроки - в частности, <em>ktap</em>.</p>
<p>Чтобы разобраться на этом <a href="bazar">базаре</a>, я начну разбираться с самых низов – того, что есть в ядре, и постепенно приду к тому, как это можно использовать.</p>
<p>В ядре Linux для этого существует несколько механизмов профилирования:</p>
<ul>
<li>Kernel tracepoints</li>
<li>Kernel probes</li>
<li>Perf events</li>
</ul>
<p>Это те фичи ядра, с помощью которых мы можем получать доступ к внутренней кухне. По сути благодаря этим механизмам мы можем измерять время выполнения функций ядра, отслеживать обращения к внешним устройствам, смотреть на поведение процессора и т.д.</p>
<p>Сами по себе эти механизмы довольно громоздки и вообще доступны только из ядра. То есть, при желании, вы можете написать свой модуль ядра, который будет заточен под вашу конкретную проблему, но смысла в этом мало, потому что на основе этих механизмов люди сделали несколько хороших профилировщиков общего назначения:</p>
<ul>
<li>ftrace</li>
<li>perf</li>
<li>SystemTap</li>
<li>ktap</li>
</ul>
<p>Посмотрим же на механизмы профилирования.</p>
<h2 id="kernel-tracepoints">Kernel tracepoints</h2>
<p>Kernel Tracepoints – механизм статического инструментирования ядра Linux<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Tracepoint – это место в коде, к которому можно привязывать заданный вами callback. <em>Tracepoint</em>’ы могут быть выключены(нет callback’а) и включены (есть callback). При этом callback’ов может быть несколько. <em>Tracepoint</em>’ы легковесны – в выключенном состоянии они делают только одну проверку типа <code>if (unlikely(tracepoint.enabled))</code>.</p>
<p>Вывод <em>tracepoint</em>’ов пишется в кольцевой буфер, который экспортируется через <em>debugfs</em>, а именно через файл <code>/sys/kernel/debug/tracing/trace</code>. В том же месте <em>debugfs</em> дерево всех событий в <code>/sys/kernel/debug/tracing/events</code>, которые можно включать и выключать по своему усмотрению.</p>
<p>Несмотря на название, <em>tracepoint</em>’ы являются основой для event-based профилирования, т.к. помимо трассировки вы можете делать в callback’е что угодно. Ядро уже инструментировано в самым разных местах, начиная с версии 2.6.28. Пример в <a href="http://lxr.free-electrons.com/source/mm/slab.c?v=3.12#L3714"><code>__do_kmalloc</code></a>:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/**</span>
<span class="co"> * __do_kmalloc - allocate memory</span>
<span class="co"> * </span>@size:<span class="co"> how many bytes of memory are required.</span>
<span class="co"> * </span>@flags:<span class="co"> the type of memory to allocate (see kmalloc).</span>
<span class="co"> * </span>@caller:<span class="co"> function caller for debug tracking of the caller</span>
<span class="co"> */</span>
<span class="dt">static</span> __always_inline <span class="dt">void</span> *__do_kmalloc(size_t size, gfp_t flags,
                                          <span class="dt">unsigned</span> <span class="dt">long</span> caller)
{
        <span class="kw">struct</span> kmem_cache *cachep;
        <span class="dt">void</span> *ret;

        <span class="co">/* If you want to save a few bytes .text space: replace</span>
<span class="co">         * __ with kmem_.</span>
<span class="co">         * Then kmalloc uses the uninlined functions instead of the inline</span>
<span class="co">         * functions.</span>
<span class="co">         */</span>
        cachep = kmalloc_slab(size, flags);
        <span class="kw">if</span> (unlikely(ZERO_OR_NULL_PTR(cachep)))
                <span class="kw">return</span> cachep;
        ret = slab_alloc(cachep, flags, caller);

        trace_kmalloc(caller, ret,
                      size, cachep-&gt;size, flags);

        <span class="kw">return</span> ret;
}</code></pre>
<p><code>trace_kmalloc</code> – это и есть <em>tracepoint</em>. Такие же есть в других важных местах ядра – в планировщиках, блочной подсистеме и т.п.</p>
<p>Все эти замечательные <em>tracepoint</em>’ы используются в большинстве профилировщиков, т.к. не требуют никакого вмешательства в ядро, срабатывают по наступлению нужного события и имеют минимальный overhead.</p>
<p>Для того, чтобы, например, в вашем модуле завести такие замечательные штуки нужно иметь много терпения, потому что делается это весьма противным образом. Пример можно посмотреть в <a href="http://lxr.free-electrons.com/source/samples/trace_events/?v=3.13"><em>samples/trace_events/</em></a>. По сути все эти <em>tracepoint</em>’ы являются чёрной магией на C макросах, разбираться в которой может только по настоящему смелый и бесстрашный человек.</p>
<p>К тому же <em>tracepoint</em>’ы не будут работать если у вас включен <code>CONFIG_MODULE_SIG=y</code>, а ваш модуль не имеет цифровой подписи. Эта, на первый взгляд, странная конфигурация является дефолтной для большинства современных дистрибутивов, включая Fedora и Ubuntu. То есть, даже если вы пройдёте 9 кругов ада, написав эти дебильные макросы, то у вас скорее всего ничего не получится.</p>
<p>Поэтому запомните важный момент:</p>
<blockquote>
<p><strong>НЕ ДЕЛАЙТЕ СВОИ TRACEPOINT’Ы, ИСПОЛЬЗУЙТЕ ТЕ, КОТОРЫЕ УЖЕ ЕСТЬ В ЯДРЕ</strong>.</p>
</blockquote>
<p>Далее я расскажу подробнее почему так происходит, так что кому это не интересно, можно читать дальше про <a href="#kprobes"><em>kprobes</em></a></p>
<p>Когда-то, во времена подготовки ядра 3.1<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> был добавлен следующий код</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">int</span> tracepoint_module_coming(<span class="kw">struct</span> module *mod)
{
          <span class="kw">struct</span> tp_module *tp_mod, *iter;
          <span class="dt">int</span> ret = <span class="dv">0</span>;

          <span class="co">/*</span>
<span class="co">           * We skip modules that tain the kernel, especially those with different</span>
<span class="co">           * module header (for forced load), to make sure we don&#39;t cause a crash.</span>
<span class="co">           */</span>
          <span class="kw">if</span> (mod-&gt;taints)
                  <span class="kw">return</span> <span class="dv">0</span>;</code></pre>
<p>Здесь говорится, что ежели модуль отравлен, то мы молча выходим и не регистрируем никаких <em>tracepoint</em>’ов.</p>
<p>В последующем условие стало более адекватным</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * We skip modules that taint the kernel, especially those with different</span>
<span class="co"> * module headers (for forced load), to make sure we don&#39;t cause a crash.</span>
<span class="co"> * Staging and out-of-tree GPL modules are fine.</span>
<span class="co"> */</span>
<span class="kw">if</span> (mod-&gt;taints &amp; ~((<span class="dv">1</span> &lt;&lt; TAINT_OOT_MODULE) | (<span class="dv">1</span> &lt;&lt; TAINT_CRAP)))
        <span class="kw">return</span> <span class="dv">0</span>;</code></pre>
<p>Ну то есть пусть они будут out-of-tree(<code>TAINT_OOT_MODULE</code>) или staging(<code>TAINT_CRAP</code>), но остальные не дадим грузить.</p>
<p>А как вы думаете что происходит когда в ядре включено <code>CONFIG_MODULE_SIG</code>, а у вас модуль неподписанный? Для него ставится флаг <code>TAINT_FORCED_MODULE</code>. И теперь проверка не проходит и модуль молча не показывает никаких трассировок. Казалось бы, что тут такого? Да эта долбаная опция стоит сейчас во всех популярных дистрибутивах, включая Ubuntu и Fedora и актуальна для ядер с 3.1.</p>
<p>Душераздирующую переписку по этому поводу можно почитать в lkml <a href="https://lkml.org/lkml/2014/2/13/488">1</a>, <a href="https://lkml.org/lkml/2014/3/4/925">2</a>.</p>
<p>Я лишь процитирую своё любимое место оттуда. Пишет Steven Rostedt, мэйнтенер ftrace и один из разработчиков <em>tracepoint</em>’ов:</p>
<pre><code>&gt; OK, this IS a major bug and needs to be fixed. This explains a couple
&gt; of reports I received about tracepoints not working, and I never
&gt; figured out why. Basically, they even did this:
&gt; 
&gt; 
&gt;    trace_printk(&quot;before tracepoint\n&quot;);
&gt;    trace_some_trace_point();
&gt;    trace_printk(&quot;after tracepoint\n&quot;);
&gt;
&gt; Enabled the tracepoint (it shows up as enabled and working in the
&gt; tools, but not the trace), but in the trace they would get:
&gt;
&gt;    before tracepoint
&gt;    after tracepoint
&gt;
&gt; and never get the actual tracepoint. But as they were debugging
&gt; something else, it was just thought that this was their bug. But it
&gt; baffled me to why that tracepoint wasn&#39;t working even though nothing in
&gt; the dmesg had any errors about tracepoints.
&gt; 
&gt; Well, this now explains it. If you compile a kernel with the following
&gt; options:
&gt; 
&gt; CONFIG_MODULE_SIG=y
&gt; # CONFIG_MODULE_SIG_FORCE is not set
&gt; # CONFIG_MODULE_SIG_ALL is not set
&gt; 
&gt; You now just disabled (silently) all tracepoints in modules. WITH NO
&gt; FREAKING ERROR MESSAGE!!!
&gt; 
&gt; The tracepoints will show up in /sys/kernel/debug/tracing/events, they
&gt; will show up in perf list, you can enable them in either perf or the
&gt; debugfs, but they will never actually be executed. You will just get
&gt; silence even though everything appeared to be working just fine.</code></pre>
<p>Резюмируя:</p>
<ul>
<li>Kernel tracepoint – легковесный механизм трассировки и профилирования кода.</li>
<li>Ядро кишит <em>tracepoint</em>’ами и они активно используются разными профилировщиками, в частности <em>perf</em> и <em>ftrace</em>.</li>
<li>Сделан на чёрном колдунстве C макросов и весьма сложен для встраивания в ваши модули ядра.</li>
<li>В вашем модуле не заработает, если
<ul>
<li>Ядро &gt;=3.1 (в 3.15 может быть исправлено)</li>
<li><code>CONFIG_MODULE_SIG=y</code></li>
<li>Ваш модуль не подписан закрытым ключом ядра</li>
</ul></li>
</ul>
<h2 id="kprobes">Kernel probes</h2>
<p>Kernel probes – механизм динамической отладки и профилирования ядра, который повзоляет прервать выполнение ядра в любом месте, передать управление обработчику и вернуть всё в зад.</p>
<p>Здесь и далее я буду использовать в качестве перевода термин <em>“проба”</em>.</p>
<p>Выглядит это так, что вы пишите модуль ядра, в котором регистрируете свой обработчик на какой-то адрес в ядре. Адреса обычно никто не указывает – указывают имя функции, работу которой хотим отследить. Судя по описанию структуры <a href="http://lxr.free-electrons.com/source/include/linux/kprobes.h?v=3.13#L73"><code>kprobe</code></a> можно указывать ещё и отступ, но в этом я не уверен. В своём обработчике выполняете что хотите – можно в лог пописать, можно в буфер, который будете экспортировать через sysfs, возможностей масса, в отличие от <em>tracepoint</em>’ов, которые только через <em>debugfs</em> можно прочитать.</p>
<p>Есть несколько видов проб:</p>
<ul>
<li><em>kprobes</em> – позволяют прервать выполнение в любом месте.</li>
<li><em>jprobes</em> (jump probes) – вставляются в начало функции и дают удобный доступ к аргументам функции. Нечто вроде прокси-функции.</li>
<li><em>kretprobes</em> – очевидно, вставляются в конце функции.</li>
</ul>
<p>Работает это в общем случае следующим образом:</p>
<ul>
<li>Регистрируем пробу на какой-нибудь адрес A</li>
<li><em>kprobe</em> находит A</li>
<li><em>kprobe</em> копирует инструкцию по адресу A</li>
<li><em>kprobe</em> заменяет инструкцию по адресу A на breakpoint (<code>int 3</code> для x86)</li>
<li>Когда выполнение доходит до пробнутого адреса, то возникает внутреннее прерывание (CPU trap)</li>
<li>Значения регистров сохраняются</li>
<li>Процессор передаёт управление <em>kprobes</em> через механизм <code>notifier_call_chain</code></li>
<li><em>kprobes</em> вызывает зарегистрированный нами обработчик</li>
</ul>
<p>Наш обработчик обычно получает на вход адрес, в котором случилось прерывание и значения регистров в структуре <code>pt_args</code>. Прототип обработчика <em>kprobes</em>:</p>
<pre class="sourceCode c"><code class="sourceCode c">    <span class="kw">typedef</span> <span class="dt">int</span> (*kprobe_break_handler_t) (<span class="kw">struct</span> kprobe *, <span class="kw">struct</span> pt_regs *);</code></pre>
<p>Эта информация обычно бесполезна, если мы не занимаемся отладкой, и именно поэтому есть <em>jprobes</em>. <em>jprobes</em> проксируют вызовы функции в зарегистрированный обработчик и поэтому обработчик имеет точно такой же прототип, что и пробируемая функция. Вот, например, обработчик для do_fork:</p>
<pre class="sourceCode c"><code class="sourceCode c">    <span class="co">/* Proxy routine having the same arguments as actual do_fork() routine */</span>
    <span class="dt">static</span> <span class="dt">long</span> jdo_fork(<span class="dt">unsigned</span> <span class="dt">long</span> clone_flags, <span class="dt">unsigned</span> <span class="dt">long</span> stack_start,
              <span class="kw">struct</span> pt_regs *regs, <span class="dt">unsigned</span> <span class="dt">long</span> stack_size,
              <span class="dt">int</span> __user *parent_tidptr, <span class="dt">int</span> __user *child_tidptr)</code></pre>
<p>Для профилирования и трассировки намного удобнее. К тому же <em>jprobes</em> работают не через <code>int 3</code>, а через <code>setjmp/longjmp</code>, которые более легковесны.</p>
<p>Ещё удобнее для профилирования пользоваться <em>kretprobes</em>. С помощью такой пробы можно указать имя функции и 2 обработчика – один будет вызываться перед вызовом функции, второй после. Особенность <em>kretprobe</em> в том, что он даёт возможность таскать между этими вызовами свои данные, в которых можно хранить, например, timestamp. Тогда перед вызовом функции мы сохраняем первый timestamp, после завершения функции опять берём timestamp и смотрим, сколько потратилось времени на выполнение фукнции. Такой пример можно посмотреть в <a href="http://lxr.free-electrons.com/source/samples/kprobes/kretprobe_example.c?v=3.13"><em>samples/kprobes/kretprobe_example.c</em></a>.</p>
<p>Вместо тысячи слов посмотрите говорящие примеры в <a href="http://lxr.free-electrons.com/source/samples/kprobes/?v=3.13"><em>samples/kprobes</em></a>.</p>
<p>Резюме:</p>
<ul>
<li><em>kprobes</em> – красивый хак для динамической отладки, трассировки и профилирования.</li>
<li>Основа для неинвазивного профилирования.</li>
</ul>
<h2 id="perf-events">Perf events</h2>
<p><em>perf_events</em> – это интерфейс доступа к аппаратно-зависимым метрикам, реализованных в процессорном PMU (Performance monitoring unit).</p>
<p>Благодаря <em>perf_events</em> можно просто просить ядро показать количество промахов в кеш первого уровня независимо от того x86 у вас или ARM. И это здорово, потому что на разных процессорах и даже на разных моделях способы прочитать аппаратные метрики из PMU могут очень сильно различаться, а вам на это плевать, потому что можно просто сказать “Покажи мне perf_event по имени cache-misses”. Какие процессоры (точнее PMU) поддерживаются можно узреть <a href="http://web.eece.maine.edu/~vweaver/projects/perf_events/support.html">здесь</a>.</p>
<p>В довесок к аппаратным метрикам были добавлены также ядерные метрики, например, число переключений контекста (<code>PERF_COUNT_SW_CONTEXT_SWITCHES</code>).</p>
<p>В довесок к этому была добавлена поддержка <em>tracepoint</em>’ов через <code>ftrace</code>.</p>
<p>Доступ к <em>perf_events</em> происходит через системный вызов <a href="http://web.eece.maine.edu/~vweaver/projects/perf_events/perf_event_open.html"><code>perf_event_open</code></a>. Вы ему передаёте тип события (аппаратные, ядерные, <em>tracepoint</em>’ы) и т.н. config, в котором конкретно говорите, что хотите отслеживать в зависимости от типа – для <em>tracepoint</em> это будет функция, для аппаратной метрики – какую метрику и т.д.</p>
<p>На всё это накручено куча всего типа группировки событий, фильтрации, сэмплирования, форматов вывода и пр., и всё это постоянно <a href="http://web.eece.maine.edu/~vweaver/projects/perf_events/abi_breakage.html">ломается от версии к версии</a>, поэтому обращаться к <em>perf_events</em> можно только с помощью утилиты <code>perf</code>, которая входит в состав ядра.</p>
<p><em>perf_events</em> и всё, что с ними связано как чума распространяется по ядру и вот уже <code>ftrace</code> становится частью <code>perf</code> (<a href="http://thread.gmane.org/gmane.linux.kernel/1136520">1</a>, <a href="https://lkml.org/lkml/2013/10/16/15">2</a>). Короче говоря, многие недовольны тем как разрабатываются <em>perf_events</em>, но поделать ничего не могут, потому что их разрабатывают Ingo Molnar<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> и Peter Zijstra, которые имеют большой авторитет и, к сожалению, зашкаливающее эго.</p>
<p>По большому счёту рассказывать про <em>perf_events</em> в отрыве от <code>perf</code> смысла нет, поэтому на этом я закончу.</p>
<h2 id="резюме">Резюме</h2>
<p>В ядре Linux существует множество механизмов, на основе и благодаря которым можно делать профилирование ядра:</p>
<ol style="list-style-type: decimal">
<li><em>tracepoints</em></li>
<li><em>kprobes</em></li>
<li><em>perf_events</em></li>
</ol>
<p>Все профилировщики ядра используют несколько или все из этих механизмов, подробности расскажу в статье про каждый профилировщик.</p>
<p>Особенности каждого из механизмов я описал, если интересно что-то большее, то гляньте в список чтения ниже или напишите мне письмо – поболтаем.</p>
<h2 id="почитать">Почитать</h2>
<ul>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/kernel_profiling_debugging_tools_0.pdf">https://events.linuxfoundation.org/sites/events/files/slides/kernel_profiling_debugging_tools_0.pdf</a></li>
<li><a href="http://events.linuxfoundation.org/sites/events/files/lcjp13_zannoni.pdf">http://events.linuxfoundation.org/sites/events/files/lcjp13_zannoni.pdf</a></li>
<li><em>tracepoints</em>:
<ul>
<li><a href="http://lxr.free-electrons.com/source/Documentation/trace/tracepoints.txt?v=3.13">Documentation/trace/tracepoints.txt</a></li>
<li><a href="http://lttng.org/files/thesis/desnoyers-dissertation-2009-12-v27.pdf">http://lttng.org/files/thesis/desnoyers-dissertation-2009-12-v27.pdf</a></li>
<li><a href="http://lwn.net/Articles/379903/">http://lwn.net/Articles/379903/</a></li>
<li><a href="http://lwn.net/Articles/381064/">http://lwn.net/Articles/381064/</a></li>
<li><a href="http://lwn.net/Articles/383362/">http://lwn.net/Articles/383362/</a></li>
</ul></li>
<li><em>kprobes</em>:
<ul>
<li><a href="http://lxr.free-electrons.com/source/Documentation/kprobes.txt?v=3.13">Documentation/kprobes.txt</a></li>
<li><a href="https://lwn.net/Articles/132196/">https://lwn.net/Articles/132196/</a></li>
</ul></li>
<li><em>perf_events</em>:
<ul>
<li><a href="http://web.eece.maine.edu/~vweaver/projects/perf_events/">http://web.eece.maine.edu/~vweaver/projects/perf_events/</a></li>
<li><a href="https://lwn.net/Articles/441209/">https://lwn.net/Articles/441209/</a></li>
</ul></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Tracepoints являются развитием ранее существовавшего механизма kernel markers.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>А именно в коммите <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b75ef8b44b1cb95f5a26484b0e2fe37a63b12b44">b75ef8b44b1cb95f5a26484b0e2fe37a63b12b44</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Автор текущего планировщика процессов CFS - Completely Fair Scheduler.<a href="#fnref3">↩</a></p></li>
</ol>
</div>

                        </div>
                    </article>
                </div>
        </div>
        <div class="push"></div>
    </div>
    <div class="footer">
    <div class="row">
    &copy; 2014 avd
    </div>
</div>

    <script src="/assets/js/vendor/jquery.js"></script>
    <script src="/assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
</body>
</html>
