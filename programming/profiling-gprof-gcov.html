<!DOCTYPE html>
<html class="no-js" lang="ru">
<head>
    <title>Профилирование в Linux. gprof и gcov</title>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/foundation.css" />
<link rel="stylesheet" href="/assets/css/foundation-icons.css" />
<link rel="stylesheet" href="/assets/css/main.css" />
<script src="/assets/js/vendor/modernizr.js"></script>

</head>
<body>
    <div class="wrapper">
        <div class="row show-for-large-up">
  <div class="small-12 columns">
    <div class="header">
      Несу подвиг добровольного безумия!
    </div>
  </div>
</div>

        <nav class="top-bar hide-for-large-up" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/">avd</a></h1>
    </li>
    <li class="toggle-topbar menu-icon">
      <a href="#">меню</a>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="left">
      <li><a href="/"><i class="fi-home"></i>&nbsp;&nbsp;Главная</a></li>
      <li><a class="disabled" href="/categories"><i class="fi-list"></i>&nbsp;&nbsp;Категории</a></li>
      <li><a href="/contacts.html"><i class="fi-at-sign"></i>&nbsp;&nbsp;Контакты</a></li>
    </ul>
  </section>
</nav>


        <div class="row">
            <div class="large-2 columns show-for-large-up">
  <ul class="side-nav">
      <li><a href="/"><i class="fi-home"></i>&nbsp;&nbsp;Главная</a></li>
      <li><a class="disabled" href="/categories"><i class="fi-list"></i>&nbsp;&nbsp;Категории</a></li>
      <li><a href="/contacts.html"><i class="fi-at-sign"></i>&nbsp;&nbsp;Контакты</a></li>
  </ul>
</div>

                <div class="large-10 small-12 columns ">
                    <article class="post-wrapper">
                        <div class="post-header">
                            <h1>Профилирование в Linux. gprof и gcov</h2>
                            <h6 class="post-meta">
                              10 фев 2014, в категории 
                              <a class="disabled" href="/categories/programming">programming</a>
                            </h6>
                        </div>
                        <div class="post-content">
                            <p>Содержание:</p>
<ol style="list-style-type: decimal">
<li><a href="/programming/profiling-intro.html">Введение</a></li>
<li>Userspace profiling: gprof, gcov</li>
<li><a href="/programming/profiling-valgrind.html">Userspace profiling: Valgrind</a></li>
<li><a href="/profiling/profiling-kernel.html">Kernel profiling: Intro</a></li>
<li>Kernel profiling: ftrace</li>
<li>Kernel profiling: perf</li>
<li>Kernel profiling: SystemTap</li>
<li>Kernel profiling: ktap</li>
<li>Vendor specific profiling: Intel VTune</li>
</ol>
<p><em>gprof</em> и <em>gcov</em> – это такие классические профилировщики, которыми с незапамятных времен пользуются Ъ-хакеры. Точнее, <em>пользовались</em>, до появления за неимением других средств (читай, Valgrind).</p>
<h2 id="gprof">gprof</h2>
<p><strong>gprof</strong> (GNU Profiler) – простейший профилировщик, который показывает в какой функции приложение проводит больше всего времени (в процентах) и сколько конкретно времени в этих функциях приложение находится (в секундах).</p>
<p>Для того, чтобы <em>gprof</em> сбацал профиль нужно перекомпилить приложение с опцией <code>-pg</code> и запустить. При этом запускать лучше несколько раз, чтобы данные профиля были более достоверными и учитывали статистическую ошибку.</p>
<h3 id="собираем-приложение-для-gprof">Собираем приложение для gprof</h3>
<p>Говорим</p>
<pre><code>[root@simplex block_hasher]# gcc -pg -g -lcrypto -pthread -lrt -Wall -Wextra block_hasher.c -o block_hasher</code></pre>
<p>Получаем бинарный файлик <code>block_hasher</code>, инструментированный для сбора статистики <em>gprof</em>’ом. Проверяется просто</p>
<pre><code> [root@simplex block_hasher]# nm block_hasher | grep mcount
                  U mcount@@GLIBC_2.2.5</code></pre>
<p>Если у вас не стрипнутый бинарник, то наличие функции <code>mcount</code> говорит, что программа инструментирована.</p>
<h3 id="профилируем-block_hasher-под-gprof">Профилируем block_hasher под gprof</h3>
<p>Для запуска под <em>gprof</em> я написал скриптец с накапливанием статистики:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/bash</span>

<span class="kw">if [</span> <span class="ot">$#</span> <span class="ot">-ne</span> 1<span class="kw"> ]</span>; <span class="kw">then</span>
    <span class="kw">echo</span> <span class="st">&quot;gprof.sh &lt;number of runs&gt;&quot;</span>
    <span class="kw">exit</span> 1
<span class="kw">fi</span>

<span class="kw">for</span> <span class="kw">i</span> in <span class="ot">$(</span><span class="kw">seq</span> 1 <span class="ot">$1)</span><span class="kw">;</span> <span class="kw">do</span>

    <span class="co"># Run profiled program</span>
    <span class="kw">./block_hasher</span> -d /dev/md126 -b 1048576 -t 10 -n 1000

    <span class="co"># Accumulate gprof statistic</span>
    <span class="kw">if [</span> <span class="ot">-e</span> gmon.sum<span class="kw"> ]</span>; <span class="kw">then</span>
        <span class="kw">gprof</span> -s block_hasher gmon.out gmon.sum
    <span class="kw">else</span>
        <span class="kw">mv</span> gmon.out gmon.sum
    <span class="kw">fi</span>
<span class="kw">done</span>

<span class="co"># Make final profile</span>
<span class="kw">gprof</span> block_hasher gmon.sum <span class="kw">&gt;</span> gmon.profile</code></pre>
<p>Каждый вызов dd порождает файлик <em>gmon.out</em>, который потом скармливается <em>gprof</em> и в итоге получается текстовый профиль приложения и граф вызовов.</p>
<p>Скриптец запускает dd заданное аргументом (<code>$1</code>) число раз и накапливает (<code>gprof -s</code>) статистику в gmon.sum.</p>
<p>В итоге <em>gprof</em> создаёт 2 профиля – <em>плоский профиль</em> (flat profile) и <em>граф вызовов</em> (call graph).</p>
<p>Плоский профиль показывает в каких функциях программа провела больше всего времени.</p>
<pre><code>Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name
100.24      0.01     0.01                             thread_func
  0.00      0.01     0.00       50     0.00     0.00  time_diff
  0.00      0.01     0.00        5     0.00     0.00  bdev_close
  0.00      0.01     0.00        5     0.00     0.00  bdev_open</code></pre>
<p>Показатели <em>gprof</em>, в принципе, понятны из названия. Как видим, всё свое время мы провели в функции потока, <strong>НО</strong> время потраченное в этой функции крайне мало – 0.01 секунды. Значит тормозит не сама функция потока, а что-то нижележащее. Понятное дело, что сам <code>pread</code> вряд ли тормозит – скорее всего функция потока проводит очень много времени в ожидании I/O и это время не учитывается в <em>gprof</em>.</p>
<p>Граф вызовов в данном случае нам не очень интересно рассматривать.</p>
<h2 id="gcov">gcov</h2>
<p><strong>gcov</strong> (сокращение от GNU Coverage) – собирает построчную статистику количества вызовов. Обычно используется в паре с <em>gprof</em>, чтобы понять в какой именно строчке тормозящей функции мы проводим больше всего времени.</p>
<p>Так же как и <em>gprof</em> требует перекомпиляции со своими флагами для инструментирования кода.</p>
<pre><code># gcc -fprofile-arcs -ftest-coverage -lcrypto -pthread -lrt -Wall -Wextra block_hasher.c -o block_hasher</code></pre>
<p><code>-fprofile-arcs</code> и <code>-ftest-coverage</code> – это опции, необходимые <em>gcov</em>.</p>
<p>После инструментирования необходимо просто запустить программу. В итоге получатся 2 файла – <em>block_hasher.gcda</em> и <em>block_hasher.gcno</em>. Их смотреть не надо.</p>
<p>Чтобы, наконец, получить вожделенную построчную статистику натравливаем <em>gcov</em> на исходник.</p>
<pre><code>[root@simplex block_hasher]# gcov block_hasher.c
File &#39;block_hasher.c&#39;
Lines executed:77.69% of 121
block_hasher.c:creating &#39;block_hasher.c.gcov&#39;</code></pre>
<p>И получаем <em>block_hasher.c.gcov</em>. Вот вырезка для <code>thread_func</code> из того, что получилось:</p>
<pre><code>   10:  159:    gap = num_threads * block_size; // Multiply here to avoid integer overflow
    -:  160:
    -:  161:    // Initialize EVP and start reading
   10:  162:    md = EVP_sha1();
   10:  163:    mdctx = EVP_MD_CTX_create();
   10:  164:    EVP_DigestInit_ex( mdctx, md, NULL );
    -:  165:
   10:  166:    get_clock( &amp;start );
10010:  167:    for( i = 0; i &lt; nblocks; i++)
    -:  168:    {
10000:  169:        offset = j-&gt;off + gap * i;
    -:  170:
    -:  171:        // Read at offset without changing file pointer
10000:  172:        err = pread( bdev-&gt;fd, buf, block_size, offset );
 9999:  173:        if( err == -1 )
    -:  174:        {
#####:  175:            fprintf(stderr, &quot;T%02d Failed to read at %llu\n&quot;, j-&gt;num, (unsigned long long)offset);
#####:  176:            perror(&quot;pread&quot;);
#####:  177:            pthread_exit(NULL);
    -:  178:        }
    -:  179:
 9999:  180:        bytes += err; // On success pread returns bytes read
    -:  181:
    -:  182:        // Update digest
 9999:  183:        EVP_DigestUpdate( mdctx, buf, block_size );
    -:  184:    }
   10:  185:    get_clock( &amp;end );
   10:  186:    sec_diff = time_diff( start, end );
    -:  187:
   10:  188:    EVP_DigestFinal_ex( mdctx, j-&gt;digest, &amp;j-&gt;digest_len );
   10:  189:    EVP_MD_CTX_destroy(mdctx);</code></pre>
<p>Ожидаемо, что больше всего времени проводится в цикле чтения блоков – 10000 раз (10 потоков * 1000 блоков). Короче, ничего нового.</p>
<p><em>gcov</em> оказался в моём случае мало полезен, однако напоследок скажу о довольно интересной штуке у <em>gcov</em> – вероятности перехода по веткам кода, которую можно получить по опции <code>-b</code>.</p>
<pre><code>[root@simplex block_hasher]# gcov -b block_hasher.c
File &#39;block_hasher.c&#39;
Lines executed:77.69% of 121
Branches executed:100.00% of 66
Taken at least once:60.61% of 66
Calls executed:51.47% of 68
block_hasher.c:creating &#39;block_hasher.c.gcov&#39;</code></pre>
<p>Для примера посмотрим на функцию <code>time_diff</code>:</p>
<pre><code>113 function time_diff called 10 returned 100% blocks executed 100%
114        10:  106:double time_diff(struct timespec start, struct timespec end)
115         -:  107:{
116         -:  108:    struct timespec diff;
117         -:  109:    double sec;
118         -:  110:
119        10:  111:    if ( (end.tv_nsec - start.tv_nsec) &lt; 0 )
120 branch  0 taken 60% (fallthrough)
121 branch  1 taken 40%
122         -:  112:    {
123         6:  113:        diff.tv_sec  = end.tv_sec - start.tv_sec - 1;
124         6:  114:        diff.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
125         -:  115:    }
126         -:  116:    else
127         -:  117:    {
128         4:  118:        diff.tv_sec  = end.tv_sec - start.tv_sec;
129         4:  119:        diff.tv_nsec = end.tv_nsec - start.tv_nsec;
130         -:  120:    }
131         -:  121:
132        10:  122:    sec = (double)diff.tv_nsec / 1000000000 + diff.tv_sec;
133         -:  123:
134        10:  124:    return sec;
135         -:  125:}</code></pre>
<p>Видно, что 60% вызовов мы считали разницу во времени с заёмом (branch 0).</p>
<h2 id="заключение">Заключение</h2>
<p><em>gprof</em> и <em>gcov</em> весьма занятные утилиты хоть их и считают морально устаревшими. С одной стороны они простые и по простому автоматизируют очевидный подход – расставить в каждой функции счётчики, а потом посмотреть где больше всего провели времени.</p>
<p>С другой стороны такой простой подход мало о чём говорит. <em>gprof</em> и <em>gcov</em> полезны в основном для приложений в пространстве пользователя, хотя есть способы использовать их для ядра, например, <a href="https://www.kernel.org/doc/Documentation/gcov.txt">для ядра Linux</a>. Тем не менее <em>gprof</em> и <em>gcov</em> бесполезны в случае, когда ваша программа проводит большую часть времени в ожидании какого-нибудь системного вызова (в моём случае <code>pread</code>).</p>
<h2 id="почитать">Почитать</h2>
<ul>
<li><a href="https://sourceware.org/binutils/docs/gprof/">Мануал по gprof</a></li>
<li><a href="http://www.ibm.com/developerworks/ru/library/l-gnuprof/">Пример от IBM</a></li>
<li><a href="http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html">Мануал университета Юты</a></li>
</ul>

                        </div>
                    </article>
                </div>
        </div>
        <div class="push"></div>
    </div>
    <div class="footer">
    <div class="row">
    &copy; 2014 avd
    </div>
</div>

    <script src="/assets/js/vendor/jquery.js"></script>
    <script src="/assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
</body>
</html>
