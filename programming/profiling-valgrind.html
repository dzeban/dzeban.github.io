<!DOCTYPE html>
<html class="no-js" lang="ru">
<head>
    <title>Профилирование в Linux. Valgrind</title>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/foundation.css" />
<link rel="stylesheet" href="/assets/css/foundation-icons.css" />
<link rel="stylesheet" href="/assets/css/main.css" />
<script src="/assets/js/vendor/modernizr.js"></script>

</head>
<body>
    <div class="wrapper">
        <div class="row show-for-large-up">
  <div class="small-12 columns">
    <div class="header">
      Несу подвиг добровольного безумия!
    </div>
  </div>
</div>

        <nav class="top-bar hide-for-large-up" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/">avd</a></h1>
    </li>
    <li class="toggle-topbar menu-icon">
      <a href="#">меню</a>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="left">
      <li><a href="/"><i class="fi-home"></i>&nbsp;&nbsp;Главная</a></li>
      <li><a class="disabled" href="/categories"><i class="fi-list"></i>&nbsp;&nbsp;Категории</a></li>
      <li><a href="/contacts.html"><i class="fi-at-sign"></i>&nbsp;&nbsp;Контакты</a></li>
    </ul>
  </section>
</nav>


        <div class="row">
            <div class="large-2 columns show-for-large-up">
  <ul class="side-nav">
      <li><a href="/"><i class="fi-home"></i>&nbsp;&nbsp;Главная</a></li>
      <li><a class="disabled" href="/categories"><i class="fi-list"></i>&nbsp;&nbsp;Категории</a></li>
      <li><a href="/contacts.html"><i class="fi-at-sign"></i>&nbsp;&nbsp;Контакты</a></li>
  </ul>
</div>

                <div class="large-10 small-12 columns ">
                    <article class="post-wrapper">
                        <div class="post-header">
                            <h1>Профилирование в Linux. Valgrind</h2>
                            <h6 class="post-meta">
                              15 мар 2014, в категории 
                              <a class="disabled" href="/categories/programming">programming</a>
                            </h6>
                        </div>
                        <div class="post-content">
                            <p>Содержание:</p>
<ol style="list-style-type: decimal">
<li><a href="/programming/profiling-intro.html">Введение</a></li>
<li><a href="/programming/profiling-gprof-gcov.html">Userspace profiling: gprof, gcov</a></li>
<li>Userspace profiling: Valgrind</li>
<li>Userspace profiling: Google Performance tools</li>
<li>Kernel profiling: Intro</li>
<li>Kernel profiling: ftrace</li>
<li>Kernel profiling: perf</li>
<li>Kernel profiling: SystemTap</li>
<li>Kernel profiling: ktap</li>
<li>Vendor specific profiling: Intel VTune</li>
</ol>
<h2 id="valgrind">Valgrind</h2>
<p>Вопреки расхожему мнению, <em>Valgrind</em> это не тулза, а набор тузов, из которых дефолтным является <em>Memcheck</em>. На текущий момент в <em>Valgrind</em> есть:</p>
<ul>
<li>Memcheck – средство обнаружений ошибок управления памяти.</li>
<li>Cachegrind – профилировщик обращений к процессорному кешу.</li>
<li>Massif – сэмплирующий профилировщик кучи.</li>
<li>Helgrind – средство обнаружения состояний гонки (race conditions).</li>
<li>DRD – средство обнаружения ошибок в многопоточных программах.</li>
</ul>
<p>В довесок к этому есть неофициальные средства, которые не включены в дистрибутив и распространяются в виде <a href="http://valgrind.org/downloads/variants.html">патчей</a> .</p>
<h2 id="memcheck">Memcheck</h2>
<p>Запускаем наш хешер под <em>Memcheck</em> и смотрим на результат:</p>
<pre><code>[root@simplex block_hasher]# valgrind --leak-check=full ./block_hasher -d /dev/md126 -b 1048576 -t 10 -n 1000
==4323== Memcheck, a memory error detector
==4323== Copyright (C) 2002-2010, and GNU GPL&#39;d, by Julian Seward et al.
==4323== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==4323== Command: ./block_hasher -d /dev/md126 -b 1048576 -t 10 -n 1000
==4323== 
==4323== 
==4323== HEAP SUMMARY:
==4323==     in use at exit: 16 bytes in 1 blocks
==4323==   total heap usage: 43 allocs, 42 frees, 10,491,624 bytes allocated
==4323== 
==4323== LEAK SUMMARY:
==4323==    definitely lost: 0 bytes in 0 blocks
==4323==    indirectly lost: 0 bytes in 0 blocks
==4323==      possibly lost: 0 bytes in 0 blocks
==4323==    still reachable: 16 bytes in 1 blocks
==4323==         suppressed: 0 bytes in 0 blocks
==4323== Reachable blocks (those to which a pointer was found) are not shown.
==4323== To see them, rerun with: --leak-check=full --show-reachable=yes
==4323== 
==4323== For counts of detected and suppressed errors, rerun with: -v
==4323== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)</code></pre>
<p>Что такое <em>definitely lost</em>, <em>indirectly lost</em> и пр. я не буду объяснять – об этом прекрасно написано в <a href="http://valgrind.org/docs/manual/mc-manual.html">документации</a>.</p>
<p>Из профиля <em>Memcheck</em> мы можем судить о том, что ошибок практически нет, за исключением небольшой утечки, 1 блок <em>still reachable</em>. Судя по сообщению</p>
<pre><code>total heap usage: 43 allocs, 42 frees, 10,491,624 bytes allocated</code></pre>
<p>я где-то забыл <code>free</code>. Проверил – действительно. В <code>bdev_open</code> при открытии устройства выделяется память под структуру <code>block_device</code>, а в <code>bdev_close</code> она не освобождается. Интересно, что <em>Memcheck</em> говорит о пропаже 16 байт, но структура <code>block_device</code> – это <code>int</code> и <code>off_t</code>, которые в сумме занимают <code>4 + 8 = 12</code>. Откуда взялись ещё 4 байта? Скорее всего выравнивание.</p>
<p>Ну да ладно лирики – исправил утечку:</p>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -240,6 +241,9 @@ void bdev_close( struct block_device *dev )</span>
         perror(&quot;close&quot;);
     }
 
<span class="ot">+    free(dev);</span>
<span class="ot">+    dev = NULL;</span>
<span class="ot">+</span>
     return;
 }</code></pre>
<p>Проверил:</p>
<pre><code>[root@simplex block_hasher]# valgrind --leak-check=full ./block_hasher -d /dev/md126 -b 1048576 -t 10 -n 1000
==15178== Memcheck, a memory error detector
==15178== Copyright (C) 2002-2010, and GNU GPL&#39;d, by Julian Seward et al.
==15178== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==15178== Command: ./block_hasher -d /dev/md0 -b 1048576 -t 10 -n 1000
==15178== 
==15178== 
==15178== HEAP SUMMARY:
==15178==     in use at exit: 0 bytes in 0 blocks
==15178==   total heap usage: 43 allocs, 43 frees, 10,491,624 bytes allocated
==15178== 
==15178== All heap blocks were freed -- no leaks are possible
==15178== 
==15178== For counts of detected and suppressed errors, rerun with: -v
==15178== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)</code></pre>
<p>Прям любо-дорого стало смотреть.</p>
<p>В качестве резюме хочется сказать, что <em>Memcheck</em> может очень много, и не только в плане обнаружения, но и в плане объяснения. Мало сказать, что в программе утечка или доступ к неинициализированным данным – надо в идеале показать в каком месте кода это происходит и как это исправлять. И <em>Memcheck</em> это делает. Он настолько хорош, что умение им пользоваться является архиважным навыком, который даже указывают в требованиях на вакансии системщиков. Короче говоря, изучайте.</p>
<h2 id="cachegrind">CacheGrind</h2>
<p><em>Cachegrind</em> – профилировщик обращений к кешу процессора. Что меня удивило в <em>Cachegrind</em>, так это то, как он собственно делает профилирование обращений к кешу процессора – он его эмулирует.</p>
<blockquote>
<p>It performs detailed simulation of the I1, D1 and L2 caches in your CPU and so can accurately pinpoint the sources of cache misses in your code.</p>
</blockquote>
<p>Если вы думаете, что это просто, то советую почитать на эту тему <a href="http://www.lighterra.com/papers/modernmicroprocessors/">замечательную статью</a>.</p>
<p>Соберём же скорее профиль!</p>
<pre><code>[root@simplex block_hasher]# valgrind --tool=cachegrind ./block_hasher -d /dev/md126 -b 1048576 -t 10 -n 1000
==9408== Cachegrind, a cache and branch-prediction profiler
==9408== Copyright (C) 2002-2010, and GNU GPL&#39;d, by Nicholas Nethercote et al.
==9408== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==9408== Command: ./block_hasher -d /dev/md126 -b 1048576 -t 10 -n 1000
==9408== 
--9408-- warning: Unknown Intel cache config value (0xff), ignoring
--9408-- warning: L2 cache not installed, ignore LL results.
==9408== 
==9408== I   refs:      167,774,548,454
==9408== I1  misses:              1,482
==9408== LLi misses:              1,479
==9408== I1  miss rate:            0.00%
==9408== LLi miss rate:            0.00%
==9408== 
==9408== D   refs:       19,989,520,856  (15,893,212,838 rd   + 4,096,308,018 wr)
==9408== D1  misses:        163,354,097  (   163,350,059 rd   +         4,038 wr)
==9408== LLd misses:         74,749,207  (    74,745,179 rd   +         4,028 wr)
==9408== D1  miss rate:             0.8% (           1.0%     +           0.0%  )
==9408== LLd miss rate:             0.3% (           0.4%     +           0.0%  )
==9408== 
==9408== LL refs:           163,355,579  (   163,351,541 rd   +         4,038 wr)
==9408== LL misses:          74,750,686  (    74,746,658 rd   +         4,028 wr)
==9408== LL miss rate:              0.0% (           0.0%     +           0.0%  )</code></pre>
<p>Первое на что лично я смотрю – промахи кеша. Но тут они &lt; 1%, а значит проблема не в этом и надо смотреть дальше.</p>
<p>Для тех, кто задаётся вопросом в каких же случаях <em>Cachegrind</em> может быть полезен, приведу пример с работы. Для ускорения расчёта синдромов для RAID6 коллега придумал улучшение для алгоритма – уменьшил количество умножений за счёт увеличения сложений и использования более хитроумной структуры данных. В теории должно было работать быстрее, но на практике, как это часто бывает, всё оказалось наоборот. После безуспешных поисков ошибок в коде погоняли под <em>Cachegrind</em>’ом и увидели miss rate в районе 80%. Пришлось отбросить идею.</p>
<h2 id="massif">Massif</h2>
<p><em>Massif</em> – профилировщик кучи, в том смысле что он показывает динамику потребления памяти, то есть сколько в определённый момент времени ваша программа сожрала.</p>
<p><em>Massif</em> делает периодические снимки состояния кучи, генерирует файлик анализа, который потом преобразуется в отчёт с помощью <code>ms_print</code>.</p>
<p>Запустили:</p>
<pre><code>[root@simplex block_hasher]# valgrind --tool=massif ./block_hasher -d /dev/md0 -b 1048576 -t 10 -n 100
==29856== Massif, a heap profiler
==29856== Copyright (C) 2003-2010, and GNU GPL&#39;d, by Nicholas Nethercote
==29856== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==29856== Command: ./block_hasher -d /dev/md0 -b 1048576 -t 10 -n 100
==29856== 
==29856== </code></pre>
<p>Получили файлик <em>massif.out.29856</em>. Сделаем отчётик:</p>
<pre><code>[root@simplex block_hasher]# ms_print massif.out.29856 &gt; massif.profile</code></pre>
<p>В отчёте получаем гистограмму выделения памяти:</p>
<pre><code>    MB
10.01^::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::#
     |:                                                                 #
     |@                                                                 #::
     |@                                                                 # :
     |@                                                                 # ::
     |@                                                                 # ::
     |@                                                                 # ::@
     |@                                                                 # ::@
     |@                                                                 # ::@
     |@                                                                 # ::@
     |@                                                                 # ::@
     |@                                                                 # ::@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
     |@                                                                 # ::@@
   0 +-----------------------------------------------------------------------&gt;Gi
     0                                                                   15.63</code></pre>
<p>И сводную таблицу выделенной памяти для нескольких наиболее примечательных сэмплов. Пример такой таблицы:</p>
<pre><code>--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 40        344,706        9,443,296        9,442,896           400            0
 41        346,448       10,491,880       10,491,472           408            0
 42        346,527       10,491,936       10,491,520           416            0
 43        346,723       10,492,056       10,491,624           432            0
 44 15,509,791,074       10,492,056       10,491,624           432            0
100.00% (10,491,624B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;99.94% (10,485,760B) 0x401169: thread_func (block_hasher.c:142)
| -&gt;99.94% (10,485,760B) 0x54189CF: start_thread (in /lib64/libpthread-2.12.so)
|   -&gt;09.99% (1,048,576B) 0x6BDC6FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0x7FDE6FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0x75DD6FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0x93E06FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0x89DF6FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0xA1E16FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0xABE26FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0xB9E36FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0xC3E46FE: ???
|   |
|   -&gt;09.99% (1,048,576B) 0xCDE56FE: ???
|
-&gt;00.06% (5,864B) in 1+ places, all below ms_print&#39;s threshold (01.00%)</code></pre>
<p>Из приведенной выше таблицы видно, что всего выделяется 10 MiB, которые на самом деле получаются 10 кусками (количество потоков) по 1 MiB (размер блока). Ничего удивительного, но было интересно.</p>
<p><em>Massif</em> – утилита, безусловно, полезная, т.к. в отличие от <em>Memcheck</em> может показать историю выделения памяти, сколько на самом деле выделяется с учётом выравнивания и учёта, а также какие участки кода используют больше всего памяти.</p>
<h2 id="helgrind">Helgrind</h2>
<p><em>Helgrind</em> – это не профилировщик, это утилита для обнаружения ошибок многопоточного программирования. Это в первую очередь инструмент для отладки программ, а не для сбора метрик.</p>
<p>Я здесь привожу пример работы с ним просто потому что он в составе <em>Valgrind</em> и благодаря ему я исправил одну ошибку.</p>
<p>Запуская его на свой <code>block_hasher</code> я был уверен, что никаких ошибок я не получу, а в итоге залип на несколько дней в исправлениях.</p>
<pre><code>[root@simplex block_hasher]# valgrind --tool=helgrind ./block_hasher -d /dev/md0 -b 1048576 -t 10 -n 100
==3930== Helgrind, a thread error detector
==3930== Copyright (C) 2007-2010, and GNU GPL&#39;d, by OpenWorks LLP et al.
==3930== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==3930== Command: ./block_hasher -d /dev/md0 -b 1048576 -t 10 -n 100
==3930== 
==3930== Thread #3 was created
==3930==    at 0x571DB2E: clone (in /lib64/libc-2.12.so)
==3930==    by 0x541E8BF: do_clone.clone.0 (in /lib64/libpthread-2.12.so)
==3930==    by 0x541EDA1: pthread_create@@GLIBC_2.2.5 (in /lib64/libpthread-2.12.so)
==3930==    by 0x4C2CE76: pthread_create_WRK (hg_intercepts.c:257)
==3930==    by 0x4019F0: main (block_hasher.c:350)
==3930== 
==3930== Thread #2 was created
==3930==    at 0x571DB2E: clone (in /lib64/libc-2.12.so)
==3930==    by 0x541E8BF: do_clone.clone.0 (in /lib64/libpthread-2.12.so)
==3930==    by 0x541EDA1: pthread_create@@GLIBC_2.2.5 (in /lib64/libpthread-2.12.so)
==3930==    by 0x4C2CE76: pthread_create_WRK (hg_intercepts.c:257)
==3930==    by 0x4019F0: main (block_hasher.c:350)
==3930== 
==3930== Possible data race during write of size 4 at 0x5200380 by thread #3
==3930==    at 0x4E98AF8: CRYPTO_malloc (in /usr/lib64/libcrypto.so.1.0.1e)
==3930==    by 0x4F16FF6: EVP_MD_CTX_create (in /usr/lib64/libcrypto.so.1.0.1e)
==3930==    by 0x401231: thread_func (block_hasher.c:163)
==3930==    by 0x4C2D01D: mythread_wrapper (hg_intercepts.c:221)
==3930==    by 0x541F9D0: start_thread (in /lib64/libpthread-2.12.so)
==3930==    by 0x75E46FF: ???
==3930==  This conflicts with a previous write of size 4 by thread #2
==3930==    at 0x4E98AF8: CRYPTO_malloc (in /usr/lib64/libcrypto.so.1.0.1e)
==3930==    by 0x4F16FF6: EVP_MD_CTX_create (in /usr/lib64/libcrypto.so.1.0.1e)
==3930==    by 0x401231: thread_func (block_hasher.c:163)
==3930==    by 0x4C2D01D: mythread_wrapper (hg_intercepts.c:221)
==3930==    by 0x541F9D0: start_thread (in /lib64/libpthread-2.12.so)
==3930==    by 0x6BE36FF: ???
==3930== 
==3930== 
==3930== For counts of detected and suppressed errors, rerun with: -v
==3930== Use --history-level=approx or =none to gain increased speed, at
==3930== the cost of reduced accuracy of conflicting-access information
==3930== ERROR SUMMARY: 9 errors from 1 contexts (suppressed: 955 from 9)</code></pre>
<p>Как видим, используемая у меня <code>EVP_MD_CTX_create</code> приводит к data race. Эта функция инициализирует контекст для расчёта контрольной суммы. Пока происходит чтение блочного устройства в этом контексте рассчитывается хеш. То есть каждое чтение блока сопровождается вызовом <code>EVP_DigestUpdate</code>, а в конце делается окончательный <code>EVP_DigestFinal_ex</code>, который записывает хеш из контекста в буфер.</p>
<p>Короче говоря, функция эта <code>EVP_MD_CTX_create</code> не моя, а из openssl, что навело меня на вопрос “А является ли вообще libcrypto<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> потокобезопасной (thread-safe)?”. Ответ – <strong>по умолчанию</strong> <a href="http://wiki.openssl.org/index.php/Libcrypto_API#Thread_Safety">нет</a>. Сам openssl предлагает зарегистрировать 2 callback-функции или замутить динамические локи (см. подробнее <a href="http://www.openssl.org/docs/crypto/threads.html">здесь</a>). Я же просто обернул инициализацию контекста в обычный pthread мьютекс и всё стало хорошо. А вообще надо как-нибудь разузнать эту ситуацию получше.</p>
<h2 id="drd">DRD</h2>
<p><em>DRD</em> – ещё один инструмент в составе <em>Valgrind</em>, который позволяет обнаруживать ошибки при работе с потоками. Отличия от <em>Helgrind</em> заключаются в якобы меньшем потреблении памяти и наличии нескольких фич.</p>
<p><em>DRD</em> считается более тщательным отладчиком потоков чем <em>Helgrind</em>. Так, например, в моём случае он нашел некий загадочный data race для <code>pread</code>. Сам по себе <code>pread</code> обещается как thread-safe, то есть его можно вызывать из разных потоков, однако <em>доступ</em> к данным может быть не синхронизирован <em>в</em> том смысле, что в одном делаем <code>pread</code>, а в другом <code>pwrite</code> и тогда будет data <em>race</em>. В моём случае блоки не пересекаются, так что я не могу диагностировать в чём здесь проблема.</p>
<pre><code>==16358== Thread 3:
==16358== Conflicting load by thread 3 at 0x0563e398 size 4
==16358==    at 0x5431030: pread (in /lib64/libpthread-2.12.so)
==16358==    by 0x4012D9: thread_func (block_hasher.c:174)
==16358==    by 0x4C33470: vgDrd_thread_wrapper (drd_pthread_intercepts.c:281)
==16358==    by 0x54299D0: start_thread (in /lib64/libpthread-2.12.so)
==16358==    by 0x75EE6FF: ???</code></pre>
<h2 id="заключение">Заключение</h2>
<p>Очевидный вывод – научитесь пользоваться Valgrind.</p>
<h2 id="почитать">Почитать</h2>
<ul>
<li>Истории успеха:
<ul>
<li><a href="http://blog.gerhards.net/2009/01/rsyslog-data-race-analysis.html">rsyslog data race analysis</a></li>
<li><a href="http://blog.evanweaver.com/2008/02/05/valgrind-and-ruby/">valgrind and ruby</a></li>
<li><a href="http://sql.dzone.com/articles/profiling-mysql-memory-usage">Profiling MySQL Memory Usage With Valgrind Massif</a></li>
</ul></li>
<li><a href="http://courses.cs.washington.edu/courses/cse326/05wi/valgrind-doc/mc_techdocs.html">The design and implementation of Valgrind. Detailed technical notes for hackers, maintainers and the overly-curious</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>libcrypto – это библиотека крипографических функций и примитивов, на которой базируется openssl.<a href="#fnref1">↩</a></p></li>
</ol>
</div>

                        </div>
                    </article>
                </div>
        </div>
        <div class="push"></div>
    </div>
    <div class="footer">
    <div class="row">
    &copy; 2014 avd
    </div>
</div>

    <script src="/assets/js/vendor/jquery.js"></script>
    <script src="/assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
</body>
</html>
